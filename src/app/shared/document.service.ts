import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';

import { Observable, AsyncSubject, of } from 'rxjs';
import { 
	map, 
	catchError, 
	distinctUntilChanged, 
	switchMap 
} from 'rxjs/operators';

// Interface is in separate file to make compiler happy
import { DocumentContents } from './document-contents';
export { DocumentContents } from './document-contents';

import { LocationService } from './location.service';
import { MarkdownService } from 'ngx-markdown';

@Injectable()
export class DocumentService {

  /** Cache of observables of fetched docs, keyed by the doc's id (url) */
  private cache = new Map<string, Observable<DocumentContents>>();

  /** Observable of the current doc. Changes as we navigate. */
  currentDocument: Observable<DocumentContents>;

  constructor(
    private http: HttpClient,
		location: LocationService,
		private markdownService: MarkdownService) {
    // Whenever the URL (minus hash/search) changes
    // we try to get the corresponding doc
    this.currentDocument = location.currentPath.pipe(
      distinctUntilChanged()).pipe(
      switchMap(path => this.getDocument(path)));
  }

  private getDocument(id: string): Observable<DocumentContents> {
    id = id || 'index';
    console.log(`getting document "${id}".`);
    if (!this.cache.has(id)) {
      this.cache.set(id, this.fetchDocument(id));
    }
    return this.cache.get(id);
  }

  private fetchDocument(id: string): Observable<DocumentContents> {
		const requestPath = `docs/${id}.md`;
    console.log(`fetching "${id}" document from "${requestPath}".`);

    // Observable subject that completes when the doc is retrieved.
    // https://github.com/ReactiveX/rxjs/blob/master/src/AsyncSubject.ts
    const docSubject = new AsyncSubject<DocumentContents>();

		this.http
      // In the real-world DocViewer, we get a JSON DocumentContents object
      // that was generated by a documentation build process.
      // .get<DocumentContents>(requestPath, {responseType: 'json'})

      // In this simpler example, we get the doc as HTML text
      // and map it into a fake DocumentContents object
			.get(requestPath, {responseType: 'text'})
			.pipe(map(contents => ({id, contents: this.getCompiledMarkdown(contents)} as DocumentContents)))
			.pipe(catchError((error: HttpErrorResponse) => {
				return error.status === 404 ?
          this.getFileNotFoundDoc(id) :
          this.getErrorDoc(id, error);
      }))
      .subscribe(docSubject);

      return docSubject.asObservable();
	}
	
	private getCompiledMarkdown(contents: string) {
		return this.markdownService.compile(contents);
	}

  private getFileNotFoundDoc(id: string): Observable<DocumentContents> {
    console.error(`Document file not found at '${id}'`);
    // Leave this doc's observable in cache  because
    // assume if not found once, it will never be found.
    return of({
      id: 'doc-file-not-found',
      contents: `<h1 class="error">Document "${id}" not found.</h1>`
    });
  }

  private getErrorDoc(id: string, error: HttpErrorResponse): Observable<DocumentContents> {
    console.error('Error fetching document', error);
    // Remove this doc's observable from cache because
    // maybe this was a transient error and we can fetch it next time
    this.cache.delete(id);
    return of({
      id: 'doc-fetching-error',
      contents: `<h1 class="error">Error ${error} while fetching document "${id}".</h1>`
    });
  }
}
